/*
 * Mastercard Checkout Solutions Card API
 * API definitions for Mastercard Secure Card on File Cards API Endpoint. The Cards endpoint enrolls a mastercard card into a specified Secure Card on File. The Get Card by ID will retrieve the MaskedCard details, for the specified card ID. Delete card by card ID will delete the previously enrolled card. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: apisupport@mastercard.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.mcs.virtualcardtokens.card.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.mcs.virtualcardtokens.card.invoker.JSON;

/**
 * Transaction
 */
@com.fasterxml.jackson.annotation.JsonInclude(com.fasterxml.jackson.annotation.JsonInclude.Include.NON_NULL)
@com.fasterxml.jackson.annotation.JsonIgnoreProperties(ignoreUnknown
= true)
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-05T17:57:04.218510319Z[Etc/UTC]")
public class Transaction {
  public static final String SERIALIZED_NAME_SRC_DIGITAL_CARD_ID = "srcDigitalCardId";
  @SerializedName(SERIALIZED_NAME_SRC_DIGITAL_CARD_ID)
  private String srcDigitalCardId;

  public static final String SERIALIZED_NAME_SERVICE_ID = "serviceId";
  @SerializedName(SERIALIZED_NAME_SERVICE_ID)
  private String serviceId;

  public static final String SERIALIZED_NAME_SRC_CONSUMER_ID = "srcConsumerId";
  @SerializedName(SERIALIZED_NAME_SRC_CONSUMER_ID)
  private String srcConsumerId;

  public static final String SERIALIZED_NAME_TOKEN_UNIQUE_REFERENCE = "tokenUniqueReference";
  @SerializedName(SERIALIZED_NAME_TOKEN_UNIQUE_REFERENCE)
  private String tokenUniqueReference;

  public static final String SERIALIZED_NAME_RECORD_ID = "recordId";
  @SerializedName(SERIALIZED_NAME_RECORD_ID)
  private String recordId;

  public static final String SERIALIZED_NAME_TRANSACTION_IDENTIFIER = "transactionIdentifier";
  @SerializedName(SERIALIZED_NAME_TRANSACTION_IDENTIFIER)
  private String transactionIdentifier;

  /**
   * The transaction type. Must be one of: • PURCHASE &#x3D; Purchase Transaction • REFUND &#x3D; Refund Transaction • PAYMENT &#x3D; Payment Transaction • ATM_WITHDRAWAL &#x3D; ATM Cash Withdrawal • CASH_DISBURSEMENT &#x3D; Cash Disbursement • ATM_DEPOSIT &#x3D; ATM Deposit • ATM_TRANSFER &#x3D; ATM Account Transfer
   */
  @JsonAdapter(TransactionTypeEnum.Adapter.class)
  public enum TransactionTypeEnum {
    PURCHASE("PURCHASE"),
    
    REFUND("REFUND"),
    
    PAYMENT("PAYMENT"),
    
    ATM_WITHDRAWAL("ATM_WITHDRAWAL"),
    
    CASH_DISBURSEMENT("CASH_DISBURSEMENT"),
    
    ATM_DEPOSIT("ATM_DEPOSIT"),
    
    ATM_TRANSFER("ATM_TRANSFER");

    private String value;

    TransactionTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TransactionTypeEnum fromValue(String value) {
      for (TransactionTypeEnum b : TransactionTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TransactionTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TransactionTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TransactionTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TransactionTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TransactionTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TRANSACTION_TYPE = "transactionType";
  @SerializedName(SERIALIZED_NAME_TRANSACTION_TYPE)
  private TransactionTypeEnum transactionType;

  public static final String SERIALIZED_NAME_AMOUNT = "amount";
  @SerializedName(SERIALIZED_NAME_AMOUNT)
  private BigDecimal amount;

  public static final String SERIALIZED_NAME_CURRENCY_CODE = "currencyCode";
  @SerializedName(SERIALIZED_NAME_CURRENCY_CODE)
  private String currencyCode;

  public static final String SERIALIZED_NAME_AUTHORIZATION_STATUS = "authorizationStatus";
  @SerializedName(SERIALIZED_NAME_AUTHORIZATION_STATUS)
  private String authorizationStatus;

  public static final String SERIALIZED_NAME_TRANSACTION_TIMESTAMP = "transactionTimestamp";
  @SerializedName(SERIALIZED_NAME_TRANSACTION_TIMESTAMP)
  private String transactionTimestamp;

  public static final String SERIALIZED_NAME_MERCHANT_NAME = "merchantName";
  @SerializedName(SERIALIZED_NAME_MERCHANT_NAME)
  private String merchantName;

  public static final String SERIALIZED_NAME_MERCHANT_TYPE = "merchantType";
  @SerializedName(SERIALIZED_NAME_MERCHANT_TYPE)
  private String merchantType;

  public static final String SERIALIZED_NAME_MERCHANT_POSTAL_CODE = "merchantPostalCode";
  @SerializedName(SERIALIZED_NAME_MERCHANT_POSTAL_CODE)
  private String merchantPostalCode;

  public static final String SERIALIZED_NAME_INSTALLMENTS = "installments";
  @SerializedName(SERIALIZED_NAME_INSTALLMENTS)
  private BigDecimal installments;

  public static final String SERIALIZED_NAME_TRANSACTION_COUNTRY_CODE = "transactionCountryCode";
  @SerializedName(SERIALIZED_NAME_TRANSACTION_COUNTRY_CODE)
  private String transactionCountryCode;

  public static final String SERIALIZED_NAME_COMBO_CARD_ACCOUNT_TYPE = "comboCardAccountType";
  @SerializedName(SERIALIZED_NAME_COMBO_CARD_ACCOUNT_TYPE)
  private String comboCardAccountType;

  public static final String SERIALIZED_NAME_ISSUER_RESPONSE_INFORMATION = "issuerResponseInformation";
  @SerializedName(SERIALIZED_NAME_ISSUER_RESPONSE_INFORMATION)
  private String issuerResponseInformation;

  public Transaction() {
  }

  public Transaction srcDigitalCardId(String srcDigitalCardId) {
    this.srcDigitalCardId = srcDigitalCardId;
    return this;
  }

   /**
   * Unique Identifier of the Card.
   * @return srcDigitalCardId
  **/
  @jakarta.annotation.Nullable
  public String getSrcDigitalCardId() {
    return srcDigitalCardId;
  }

  public void setSrcDigitalCardId(String srcDigitalCardId) {
    this.srcDigitalCardId = srcDigitalCardId;
  }


  public Transaction serviceId(String serviceId) {
    this.serviceId = serviceId;
    return this;
  }

   /**
   * A unique identifier assigned by Mastercard for which tokens are created uniquely for the entity onboarded.
   * @return serviceId
  **/
  @jakarta.annotation.Nullable
  public String getServiceId() {
    return serviceId;
  }

  public void setServiceId(String serviceId) {
    this.serviceId = serviceId;
  }


  public Transaction srcConsumerId(String srcConsumerId) {
    this.srcConsumerId = srcConsumerId;
    return this;
  }

   /**
   * Consumer Reference Identifier as generated by the Mastercard commerce platform.
   * @return srcConsumerId
  **/
  @jakarta.annotation.Nullable
  public String getSrcConsumerId() {
    return srcConsumerId;
  }

  public void setSrcConsumerId(String srcConsumerId) {
    this.srcConsumerId = srcConsumerId;
  }


  public Transaction tokenUniqueReference(String tokenUniqueReference) {
    this.tokenUniqueReference = tokenUniqueReference;
    return this;
  }

   /**
   * A unique reference assigned following the allocation of a token used to identify the token for the duration of its lifetime
   * @return tokenUniqueReference
  **/
  @jakarta.annotation.Nullable
  public String getTokenUniqueReference() {
    return tokenUniqueReference;
  }

  public void setTokenUniqueReference(String tokenUniqueReference) {
    this.tokenUniqueReference = tokenUniqueReference;
  }


  public Transaction recordId(String recordId) {
    this.recordId = recordId;
    return this;
  }

   /**
   * Unique identifier for this transaction record. Opaque value
   * @return recordId
  **/
  @jakarta.annotation.Nonnull
  public String getRecordId() {
    return recordId;
  }

  public void setRecordId(String recordId) {
    this.recordId = recordId;
  }


  public Transaction transactionIdentifier(String transactionIdentifier) {
    this.transactionIdentifier = transactionIdentifier;
    return this;
  }

   /**
   * A unique identifier for the transaction that is used to match a transaction event on the device (for example, a contactless tap, or a DSRP payment) to a transaction details record provided by the TDS
   * @return transactionIdentifier
  **/
  @jakarta.annotation.Nullable
  public String getTransactionIdentifier() {
    return transactionIdentifier;
  }

  public void setTransactionIdentifier(String transactionIdentifier) {
    this.transactionIdentifier = transactionIdentifier;
  }


  public Transaction transactionType(TransactionTypeEnum transactionType) {
    this.transactionType = transactionType;
    return this;
  }

   /**
   * The transaction type. Must be one of: • PURCHASE &#x3D; Purchase Transaction • REFUND &#x3D; Refund Transaction • PAYMENT &#x3D; Payment Transaction • ATM_WITHDRAWAL &#x3D; ATM Cash Withdrawal • CASH_DISBURSEMENT &#x3D; Cash Disbursement • ATM_DEPOSIT &#x3D; ATM Deposit • ATM_TRANSFER &#x3D; ATM Account Transfer
   * @return transactionType
  **/
  @jakarta.annotation.Nonnull
  public TransactionTypeEnum getTransactionType() {
    return transactionType;
  }

  public void setTransactionType(TransactionTypeEnum transactionType) {
    this.transactionType = transactionType;
  }


  public Transaction amount(BigDecimal amount) {
    this.amount = amount;
    return this;
  }

   /**
   * Numeric value of transaction amount.
   * @return amount
  **/
  @jakarta.annotation.Nullable
  public BigDecimal getAmount() {
    return amount;
  }

  public void setAmount(BigDecimal amount) {
    this.amount = amount;
  }


  public Transaction currencyCode(String currencyCode) {
    this.currencyCode = currencyCode;
    return this;
  }

   /**
   * ISO 4217 three-digit currency code
   * @return currencyCode
  **/
  @jakarta.annotation.Nonnull
  public String getCurrencyCode() {
    return currencyCode;
  }

  public void setCurrencyCode(String currencyCode) {
    this.currencyCode = currencyCode;
  }


  public Transaction authorizationStatus(String authorizationStatus) {
    this.authorizationStatus = authorizationStatus;
    return this;
  }

   /**
   * &lt;h3&gt;The authorization status of the transaction. Must be one of:&lt;/h3&gt; &lt;ul&gt;   &lt;li&gt;AUTHORIZED &lt;/li&gt;   &lt;li&gt;DECLINED &lt;/li&gt;   &lt;li&gt;CLEARED &lt;/li&gt;   &lt;li&gt;REVERSED &lt;/li&gt; &lt;/ul&gt;
   * @return authorizationStatus
  **/
  @jakarta.annotation.Nonnull
  public String getAuthorizationStatus() {
    return authorizationStatus;
  }

  public void setAuthorizationStatus(String authorizationStatus) {
    this.authorizationStatus = authorizationStatus;
  }


  public Transaction transactionTimestamp(String transactionTimestamp) {
    this.transactionTimestamp = transactionTimestamp;
    return this;
  }

   /**
   * &lt;h3&gt;The date/time when the transaction occurred. In ISO 8601 extended format as one of the following:&lt;/h3&gt; &lt;ul&gt;   &lt;li&gt;YYYY-MM-DDThh:mm:ss[.sss]Z &lt;/li&gt;   &lt;li&gt;YYYY-MM-DDThh:mm:ss[.sss]±hh:mm &lt;/li&gt;   Where [.sss] is optional and can be 1 to 3 digits &lt;/ul&gt;
   * @return transactionTimestamp
  **/
  @jakarta.annotation.Nonnull
  public String getTransactionTimestamp() {
    return transactionTimestamp;
  }

  public void setTransactionTimestamp(String transactionTimestamp) {
    this.transactionTimestamp = transactionTimestamp;
  }


  public Transaction merchantName(String merchantName) {
    this.merchantName = merchantName;
    return this;
  }

   /**
   * The merchant (\&quot;doing business as\&quot;) name
   * @return merchantName
  **/
  @jakarta.annotation.Nullable
  public String getMerchantName() {
    return merchantName;
  }

  public void setMerchantName(String merchantName) {
    this.merchantName = merchantName;
  }


  public Transaction merchantType(String merchantType) {
    this.merchantType = merchantType;
    return this;
  }

   /**
   * The merchant’s type of business or service. Must be a valid Merchant Category Code (MCC).
   * @return merchantType
  **/
  @jakarta.annotation.Nullable
  public String getMerchantType() {
    return merchantType;
  }

  public void setMerchantType(String merchantType) {
    this.merchantType = merchantType;
  }


  public Transaction merchantPostalCode(String merchantPostalCode) {
    this.merchantPostalCode = merchantPostalCode;
    return this;
  }

   /**
   * The postal code (for example, zipcode in the U.S.) of the merchant
   * @return merchantPostalCode
  **/
  @jakarta.annotation.Nullable
  public String getMerchantPostalCode() {
    return merchantPostalCode;
  }

  public void setMerchantPostalCode(String merchantPostalCode) {
    this.merchantPostalCode = merchantPostalCode;
  }


  public Transaction installments(BigDecimal installments) {
    this.installments = installments;
    return this;
  }

   /**
   * The number of installments for the transaction.
   * @return installments
  **/
  @jakarta.annotation.Nullable
  public BigDecimal getInstallments() {
    return installments;
  }

  public void setInstallments(BigDecimal installments) {
    this.installments = installments;
  }


  public Transaction transactionCountryCode(String transactionCountryCode) {
    this.transactionCountryCode = transactionCountryCode;
    return this;
  }

   /**
   * The country in which the transaction was performed. Expressed as a 3-letter (alpha-3) country code as defined in ISO 3166-1.
   * @return transactionCountryCode
  **/
  @jakarta.annotation.Nullable
  public String getTransactionCountryCode() {
    return transactionCountryCode;
  }

  public void setTransactionCountryCode(String transactionCountryCode) {
    this.transactionCountryCode = transactionCountryCode;
  }


  public Transaction comboCardAccountType(String comboCardAccountType) {
    this.comboCardAccountType = comboCardAccountType;
    return this;
  }

   /**
   * &lt;h3&gt;Indicator if Credit or Debit was chosen for a tokenized combo card at the time of the transaction. Value must be one of:&lt;/h3&gt; &lt;ul&gt;   &lt;li&gt;CREDIT &lt;/li&gt;   &lt;li&gt;DEBIT &lt;/li&gt; &lt;/ul&gt;
   * @return comboCardAccountType
  **/
  @jakarta.annotation.Nullable
  public String getComboCardAccountType() {
    return comboCardAccountType;
  }

  public void setComboCardAccountType(String comboCardAccountType) {
    this.comboCardAccountType = comboCardAccountType;
  }


  public Transaction issuerResponseInformation(String issuerResponseInformation) {
    this.issuerResponseInformation = issuerResponseInformation;
    return this;
  }

   /**
   * &lt;h3&gt;Additional information provided by the issuer for a declined transaction.Only returned if the transaction is declined and the Mobile Wallet Application is configured to receive this data. Value must be one of:&lt;/h3&gt; &lt;ul&gt;   &lt;li&gt;INVALID_CARD_NUMBER &lt;/li&gt;   &lt;li&gt;FORMAT_ERROR &lt;/li&gt;   &lt;li&gt;MAX_AMOUNT_EXCEEDED &lt;/li&gt;   &lt;li&gt;EXPIRED_CARD   &lt;li&gt;PIN_AUTHORIZATION_FAILED &lt;/li&gt;   &lt;li&gt;TRANSACTION_NOT_PERMITTED &lt;/li&gt;   &lt;li&gt;RESTRICTED_CARD  &lt;/li&gt;   &lt;li&gt;WITHDRAWAL_COUNT_EXCEEDED  &lt;/li&gt;   &lt;li&gt;PIN_TRIES_NUMBER_EXCEEDED&lt;/li&gt;   &lt;li&gt;INCORRECT_PIN &lt;/li&gt;   &lt;li&gt;DUPLICATE_TRANSMISSION&lt;/li&gt; &lt;/ul&gt;
   * @return issuerResponseInformation
  **/
  @jakarta.annotation.Nullable
  public String getIssuerResponseInformation() {
    return issuerResponseInformation;
  }

  public void setIssuerResponseInformation(String issuerResponseInformation) {
    this.issuerResponseInformation = issuerResponseInformation;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the Transaction instance itself
   */
  public Transaction putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Transaction transaction = (Transaction) o;
    return Objects.equals(this.srcDigitalCardId, transaction.srcDigitalCardId) &&
        Objects.equals(this.serviceId, transaction.serviceId) &&
        Objects.equals(this.srcConsumerId, transaction.srcConsumerId) &&
        Objects.equals(this.tokenUniqueReference, transaction.tokenUniqueReference) &&
        Objects.equals(this.recordId, transaction.recordId) &&
        Objects.equals(this.transactionIdentifier, transaction.transactionIdentifier) &&
        Objects.equals(this.transactionType, transaction.transactionType) &&
        Objects.equals(this.amount, transaction.amount) &&
        Objects.equals(this.currencyCode, transaction.currencyCode) &&
        Objects.equals(this.authorizationStatus, transaction.authorizationStatus) &&
        Objects.equals(this.transactionTimestamp, transaction.transactionTimestamp) &&
        Objects.equals(this.merchantName, transaction.merchantName) &&
        Objects.equals(this.merchantType, transaction.merchantType) &&
        Objects.equals(this.merchantPostalCode, transaction.merchantPostalCode) &&
        Objects.equals(this.installments, transaction.installments) &&
        Objects.equals(this.transactionCountryCode, transaction.transactionCountryCode) &&
        Objects.equals(this.comboCardAccountType, transaction.comboCardAccountType) &&
        Objects.equals(this.issuerResponseInformation, transaction.issuerResponseInformation)&&
        Objects.equals(this.additionalProperties, transaction.additionalProperties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(srcDigitalCardId, serviceId, srcConsumerId, tokenUniqueReference, recordId, transactionIdentifier, transactionType, amount, currencyCode, authorizationStatus, transactionTimestamp, merchantName, merchantType, merchantPostalCode, installments, transactionCountryCode, comboCardAccountType, issuerResponseInformation, additionalProperties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Transaction {\n");
    sb.append("    srcDigitalCardId: ").append(toIndentedString(srcDigitalCardId)).append("\n");
    sb.append("    serviceId: ").append(toIndentedString(serviceId)).append("\n");
    sb.append("    srcConsumerId: ").append(toIndentedString(srcConsumerId)).append("\n");
    sb.append("    tokenUniqueReference: ").append(toIndentedString(tokenUniqueReference)).append("\n");
    sb.append("    recordId: ").append(toIndentedString(recordId)).append("\n");
    sb.append("    transactionIdentifier: ").append(toIndentedString(transactionIdentifier)).append("\n");
    sb.append("    transactionType: ").append(toIndentedString(transactionType)).append("\n");
    sb.append("    amount: ").append(toIndentedString(amount)).append("\n");
    sb.append("    currencyCode: ").append(toIndentedString(currencyCode)).append("\n");
    sb.append("    authorizationStatus: ").append(toIndentedString(authorizationStatus)).append("\n");
    sb.append("    transactionTimestamp: ").append(toIndentedString(transactionTimestamp)).append("\n");
    sb.append("    merchantName: ").append(toIndentedString(merchantName)).append("\n");
    sb.append("    merchantType: ").append(toIndentedString(merchantType)).append("\n");
    sb.append("    merchantPostalCode: ").append(toIndentedString(merchantPostalCode)).append("\n");
    sb.append("    installments: ").append(toIndentedString(installments)).append("\n");
    sb.append("    transactionCountryCode: ").append(toIndentedString(transactionCountryCode)).append("\n");
    sb.append("    comboCardAccountType: ").append(toIndentedString(comboCardAccountType)).append("\n");
    sb.append("    issuerResponseInformation: ").append(toIndentedString(issuerResponseInformation)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("srcDigitalCardId");
    openapiFields.add("serviceId");
    openapiFields.add("srcConsumerId");
    openapiFields.add("tokenUniqueReference");
    openapiFields.add("recordId");
    openapiFields.add("transactionIdentifier");
    openapiFields.add("transactionType");
    openapiFields.add("amount");
    openapiFields.add("currencyCode");
    openapiFields.add("authorizationStatus");
    openapiFields.add("transactionTimestamp");
    openapiFields.add("merchantName");
    openapiFields.add("merchantType");
    openapiFields.add("merchantPostalCode");
    openapiFields.add("installments");
    openapiFields.add("transactionCountryCode");
    openapiFields.add("comboCardAccountType");
    openapiFields.add("issuerResponseInformation");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("recordId");
    openapiRequiredFields.add("transactionType");
    openapiRequiredFields.add("currencyCode");
    openapiRequiredFields.add("authorizationStatus");
    openapiRequiredFields.add("transactionTimestamp");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to Transaction
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Transaction.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Transaction is not found in the empty JSON string", Transaction.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Transaction.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("srcDigitalCardId") != null && !jsonObj.get("srcDigitalCardId").isJsonNull()) && !jsonObj.get("srcDigitalCardId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `srcDigitalCardId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("srcDigitalCardId").toString()));
      }
      if ((jsonObj.get("serviceId") != null && !jsonObj.get("serviceId").isJsonNull()) && !jsonObj.get("serviceId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceId").toString()));
      }
      if ((jsonObj.get("srcConsumerId") != null && !jsonObj.get("srcConsumerId").isJsonNull()) && !jsonObj.get("srcConsumerId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `srcConsumerId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("srcConsumerId").toString()));
      }
      if ((jsonObj.get("tokenUniqueReference") != null && !jsonObj.get("tokenUniqueReference").isJsonNull()) && !jsonObj.get("tokenUniqueReference").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tokenUniqueReference` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tokenUniqueReference").toString()));
      }
      if (!jsonObj.get("recordId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `recordId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("recordId").toString()));
      }
      if ((jsonObj.get("transactionIdentifier") != null && !jsonObj.get("transactionIdentifier").isJsonNull()) && !jsonObj.get("transactionIdentifier").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `transactionIdentifier` to be a primitive type in the JSON string but got `%s`", jsonObj.get("transactionIdentifier").toString()));
      }
      if (!jsonObj.get("transactionType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `transactionType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("transactionType").toString()));
      }
      // validate the required field `transactionType`
      TransactionTypeEnum.validateJsonElement(jsonObj.get("transactionType"));
      if (!jsonObj.get("currencyCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `currencyCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("currencyCode").toString()));
      }
      if (!jsonObj.get("authorizationStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `authorizationStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("authorizationStatus").toString()));
      }
      if (!jsonObj.get("transactionTimestamp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `transactionTimestamp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("transactionTimestamp").toString()));
      }
      if ((jsonObj.get("merchantName") != null && !jsonObj.get("merchantName").isJsonNull()) && !jsonObj.get("merchantName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `merchantName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("merchantName").toString()));
      }
      if ((jsonObj.get("merchantType") != null && !jsonObj.get("merchantType").isJsonNull()) && !jsonObj.get("merchantType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `merchantType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("merchantType").toString()));
      }
      if ((jsonObj.get("merchantPostalCode") != null && !jsonObj.get("merchantPostalCode").isJsonNull()) && !jsonObj.get("merchantPostalCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `merchantPostalCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("merchantPostalCode").toString()));
      }
      if ((jsonObj.get("transactionCountryCode") != null && !jsonObj.get("transactionCountryCode").isJsonNull()) && !jsonObj.get("transactionCountryCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `transactionCountryCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("transactionCountryCode").toString()));
      }
      if ((jsonObj.get("comboCardAccountType") != null && !jsonObj.get("comboCardAccountType").isJsonNull()) && !jsonObj.get("comboCardAccountType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `comboCardAccountType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("comboCardAccountType").toString()));
      }
      if ((jsonObj.get("issuerResponseInformation") != null && !jsonObj.get("issuerResponseInformation").isJsonNull()) && !jsonObj.get("issuerResponseInformation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `issuerResponseInformation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("issuerResponseInformation").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Transaction.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Transaction' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Transaction> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Transaction.class));

       return (TypeAdapter<T>) new TypeAdapter<Transaction>() {
           @Override
           public void write(JsonWriter out, Transaction value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additional properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   JsonElement jsonElement = gson.toJsonTree(entry.getValue());
                   if (jsonElement.isJsonArray()) {
                     obj.add(entry.getKey(), jsonElement.getAsJsonArray());
                   } else {
                     obj.add(entry.getKey(), jsonElement.getAsJsonObject());
                   }
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public Transaction read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             JsonObject jsonObj = jsonElement.getAsJsonObject();
             // store additional fields in the deserialized instance
             Transaction instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of Transaction given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of Transaction
  * @throws IOException if the JSON string is invalid with respect to Transaction
  */
  public static Transaction fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Transaction.class);
  }

 /**
  * Convert an instance of Transaction to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

